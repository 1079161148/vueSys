1 .index值不是一定不变的，如果不加key值的话，删除前面的项。后面的index可能变也可能不变，比如加个定时器的时候会变，不加定时器不会变

2 .不加key的话，更新机制的进行diff的时候是会全部比较的，比如删除第一个的话，后面的元素其实都不一样，会一项一项的比较。然后全部元素都替换，没有做到最小更新。而且里面的传的值也会变，如果这个时候你要根据里面的值删除元素的话，就会出错，尤其是加了定时器之后

3 .所以这个key值对数据改变之后的diff更新比较有很大的性能提升，或者说有了key和没有key是两种比较和更新机制

4 .使用v-for更新已渲染的元素列表时，默认采用旧地复用策略，会复用之前的元素，有的时候使用index来做为key值，其实不是特别推荐的。可能会发生变化，最好是时间戳加上一个自增的数字

5 .如果有key的话，就会根据key值去判断某个是否修改，重新渲染这一项

6 .虚拟dom的diff算法：
1 .两个相同的组件产生类似的dom结构，不同的组件产生不同的dom结构
2 .同一层级的一组节点，可以通过唯一的id进行区分
3 .当一层有很多相同的节点的时候，也就是列表节点时，diff算法的更新过程默认情况是遵循以上原则

v-for场景
1 .当使用v-for更新已经渲染过的元素列表时，默认的使用”旧地复用“策略，如果数据项的顺序被改变，Vue是不会移动dom来匹配数据项的顺序，而是简单的复用此处的每个元素，并且确保他在特定索引下显示已被渲染过的元素
2 .这个模式默认是高效的，但是只适用于不依赖子组件状态或临时DOM钻港台，比如列表渲染输出
3 .为了给Vue一个提示，使他可以追踪每个节点的身份，从而重用和重新排序现有元素，这就需要为每一个项提供一个唯一的key属性
4 .注意：不添加key的性能其实更加优秀。除了想要性能或者输出非常的内容非常简单
5 .不要使用对象或者数组之类的非原始值作为v-for的key，用字符串或者整数类型的值来取代；

简言之 key的作用主要是为了高效的更新虚拟DOM